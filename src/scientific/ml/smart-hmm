// **********************************************************************
// Copyright (c) Artur M. Brodzki 2020. All rights reserved.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// **********************************************************************

#ifndef SCIENTIFIC_ML_SMART_HMM_H
#define SCIENTIFIC_ML_SMART_HMM_H

#include <algorithm>
#include <armadillo>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
#include <unistd.h>
#include <unordered_map>
#include <vector>

namespace scientific { namespace ml {

// S - type representing sequence generated by HMM
// E - type representing one element of that sequence
// For most cases, S will be string, and E will be char
template<class E, class S>
class Hmm
{
  public:
    struct Path
    {
        std::vector<unsigned> states;
        S sequence;
        double prob;
        Path()
            : prob( 0 )
        {
        }
    };

  private:
    unsigned current_state;
    arma::mat transitions;
    arma::mat emissions;
    S alphabet;

    // Auxiliary function
    // Given vector of N probabilities (summing up to 1),
    // function returns unsigned from 0 to N-1
    // according to specified probabilities distribution
    static unsigned random_element( const arma::mat& );

  public:
    // Assumes uniform probability distribution for transitions and emissions
    Hmm( unsigned num_states, const S&, unsigned );
    // Construct an HMM object with given transitions and emissions probabilities
    Hmm( const arma::mat& transitions, const arma::mat& emissions, const S&, unsigned );

    // get possible outputs
    S get_alphabet() const;
    // get vector of HMM states
    std::vector<unsigned> get_states() const;
    // get emission probability
    double get_emission( unsigned, E ) const;
    // get transition probability
    double get_transition( unsigned, unsigned ) const;
    // get current HMM state
    unsigned get_current_state() const;
    // set current HMM state
    void set_current_state( unsigned );

    // Move HMM machine to the next state and return an output char,
    // according to current transitions and emissions probabilities.
    // Returns output char and probability of transition
    std::pair<E, double> next_step();
    // Generate random sequence with specified length
    Path generate_sequence( unsigned );
    // Generate random sequence up to given output value
    // Path generate_sequence( E end_char );
    // Find Viterbi path for given sequence and initial state
    Path find_viterbi_path( const S& sequence );
    Path find_viterbi_path( const S& sequence, const arma::mat& );

    // Print HMM state to stream
    template<class E2, class S2>
    friend std::ostream& operator<<( std::ostream&, const Hmm<E2, S2>& );
};

// ******************
// CONSTRUCTORS
// ******************

template<class E, class S>
Hmm<E, S>::Hmm( unsigned num_states, const S& alphabet, unsigned initial_state )
    : alphabet( alphabet )
    , current_state( initial_state )
{
    transitions.set_size( num_states, num_states );
    transitions.fill( 1 / double( num_states ) );
    emissions.set_size( num_states, alphabet.size() );
    emissions.fill( 1 / double( alphabet.size() ) );
}

template<class E, class S>
Hmm<E, S>::Hmm( const arma::mat& transitions,
                const arma::mat& emissions,
                const S& alphabet,
                unsigned initial_state )
    : current_state( initial_state )
    , transitions( transitions )
    , emissions( emissions )
    , alphabet( alphabet )
{
    bool valid_sizes = transitions.n_rows == transitions.n_cols &&
                       transitions.n_rows == emissions.n_rows &&
                       emissions.n_cols == alphabet.size();
    if( not valid_sizes ) {
        throw std::invalid_argument( "Transmission and/or emissions matrix size invalid!" );
    }
}

// *******************
// GETTERS & SETTERS
// *******************

template<class E, class S>
std::vector<unsigned> Hmm<E, S>::get_states() const
{
    std::vector<unsigned> result;
    for( unsigned i = 0; i < transitions.n_rows; ++i ) {
        result.push_back( i );
    }
    return result;
}

template<class E, class S>
S Hmm<E, S>::get_alphabet() const
{
    return alphabet;
}

template<class E, class S>
double Hmm<E, S>::get_emission( unsigned state, E e ) const
{
    unsigned i = 0;
    for( i = 0; i < alphabet.size(); ++i ) {
        if( alphabet[i] == e ) {
            break;
        }
    }
    return emissions( state, i );
}

template<class E, class S>
double Hmm<E, S>::get_transition( unsigned state_from, unsigned state_to ) const
{
    return transitions( state_from, state_to );
}

template<class E, class S>
unsigned Hmm<E, S>::get_current_state() const
{
    return current_state;
}

template<class E, class S>
void Hmm<E, S>::set_current_state( unsigned state )
{
    if( state > get_states().back() ) {
        throw std::out_of_range();
    }
    current_state = state;
}

// ******************
// PRIVATE MEMBERS
// ******************

template<class E, class S>
unsigned Hmm<E, S>::random_element( const arma::mat& probabilities )
{
    double seed = double( rand() % 1000000 ) / 1000000;
    unsigned i = 0;
    do {
        seed = seed - probabilities( i );
        if( seed < 0 ) {
            break;
        }
        ++i;
    } while( i < probabilities.n_elem );
    return i;
}

// *****************
// PUBLIC MEMBERS
// *****************

template<class E, class S>
std::pair<E, double> Hmm<E, S>::next_step()
{
    arma::mat current_transitions =
      transitions( arma::span( current_state ), arma::span( 0, get_states().size() - 1 ) );
    arma::mat current_emissions =
      emissions( arma::span( current_state ), arma::span( 0, get_alphabet().size() - 1 ) );

    unsigned new_state = random_element( current_transitions );
    double new_state_prob = transitions( current_state, new_state );
    E new_output = alphabet[random_element( current_emissions )];
    double new_output_prob = get_emission( current_state, new_output );

    current_state = new_state;

    return std::make_pair( new_output, log10( new_state_prob ) + log10( new_output_prob ) );
}

template<class E, class S>
typename Hmm<E, S>::Path Hmm<E, S>::generate_sequence( unsigned sequence_length )
{
    Hmm<E, S>::Path result;
    for( unsigned i = 0; i < sequence_length; ++i ) {
        result.states.push_back( current_state );
        auto next = Hmm<E, S>::next_step();
        result.sequence.push_back( next.first );
        result.prob += next.second;
    }
    return result;
}

template<class E, class S>
typename Hmm<E, S>::Path Hmm<E, S>::find_viterbi_path( const S& sequence )
{
    arma::mat pi( 1, transitions.n_cols );
    pi.fill( 1 / double( get_states().size() - 1 ) );
    return find_viterbi_path( sequence, pi );
}

template<class E, class S>
typename Hmm<E, S>::Path Hmm<E, S>::find_viterbi_path( const S& sequence, const arma::mat& pi )
{
    if( not ( pi.n_rows == 1 && pi.n_cols == transitions.n_cols ) ) {
        throw std::invalid_argument( "Initial probabilities matrix invalid size!" );
    }

    unsigned num_states = get_states().size();

    arma::mat t1( num_states, sequence.size() );
    arma::mat t2( num_states, sequence.size() );

    // initialize tables
    for( unsigned i = 0; i < num_states; ++i ) {
        t1( i, 0 ) = pi( i ) * get_emission( i, sequence[0] );
        t2( i, 0 ) = 0;
    }

    // Dynamically fill tables
    for( unsigned j = 1; j < sequence.size(); ++j ) {
        for( unsigned i = 0; i < num_states; ++i ) {

            double valmax = 0;
            double argmax = 0;
            for( unsigned k = 0; k < num_states; ++k ) {
                double val =
                  t1( k, j - 1 ) * get_transition( k, i ) * get_emission( i, sequence[j] );
                if( val > valmax ) {
                    valmax = val;
                    argmax = k;
                }
            }
            t1( i, j ) = valmax;
            t2( i, j ) = argmax;
        }
    }

    // Calculate path
    arma::umat z( 1, sequence.size() );
    double zmax = 0;
    double zargmax = 0;
    for( unsigned k = 0; k < num_states; ++k ) {
        if( t1( k, num_states - 1 ) > zmax ) {
            zmax = t1( k, sequence.size() - 1 );
            zargmax = k;
        }
    }
    z( 0, sequence.size() - 1 ) = zargmax;
    for( unsigned j = sequence.size() - 1; j > 1; --j ) {
        z( 0, j - 1 ) = t2( z( 0, j ), j );
    }
    // Return result
    Hmm<E, S>::Path result;
    result.sequence = sequence;
    for( unsigned i = 0; i < sequence.size(); ++i ) {
        result.states.push_back( z( 0, i ) );
    }
    result.prob = 0;
    return result;
}

// ****************
// FRIEND METHODS
// ****************

template<class E, class S>
std::ostream& operator<<( std::ostream& os, const Hmm<E, S>& h )
{
    os << "Current state: " << std::endl
       << h.current_state << std::endl
       << "Transitions: " << std::endl
       << h.transitions << std::endl
       << "Emissions: " << std::endl
       << h.emissions;
    return os;
};

}} // namespace scientific::ml

#endif // SCIENTIFIC_ML_SMART_HMM_H
